<?xml version="1.0" encoding="Windows-1250"?>
<questions>
    <question id="1">
        <otazka cesta="">Pro vytvoøení objektu používáme</otazka>
        <spravna cesta="">klíèové slovo "new" a volání konstruktoru</spravna>
        <spatna cesta="">instance se vytváøí automaticky kompilátorem pøi prvním použití v promìnné</spatna>
        <spatna cesta="">klíèové slovo "create" a volání konstruktoru</spatna>
        <spatna cesta="">klíèové slovo "alloc" a volání konstruktoru</spatna>
        <spatna cesta="">klíèové slovo "new" a volání destruktoru</spatna>
    </question>
    <question id="2">
        <otazka cesta="">Oznaète pravdivá tvrzení pro finální tøídu X</otazka>
        <spravna cesta="">Lze volat metody u promìnné typu X</spravna>
        <spravna cesta="">Od X lze vytvoøit instanci </spravna>
        <spatna cesta="">Mùže mít libovolný poèet pøedkù - jiných tøíd.</spatna>
        <spatna cesta="">Lze vytvoøit tøídu, která bude potomkem/implementací X</spatna>
        <spatna cesta="">Tato konstrukce v jazyce Java neexistuje</spatna>
    </question>
    <question id="3">
        <otazka cesta="">Klíèové slovo "this" se používá k</otazka>
        <spatna cesta="">v pøedkovi k odkazování na potomka</spatna>
        <spatna cesta="">v metodì k odkazování na tuto metodu</spatna>
        <spatna cesta="">v potomkovi k odkazování na pøedka</spatna>
        <spatna cesta=""> k odkazování na aktuální instanci virtuálního stroje</spatna>
        <spravna cesta="">v metodì k odkazování na objekt, ze kterého je aktuální metoda volána</spravna>
    </question>
    <question id="4">
        <otazka cesta="">Rozhranní se definuje pomocí klíèového slova</otazka>
        <spravna cesta="">interface</spravna>
        <spatna cesta="">public</spatna>
        <spatna cesta="">class</spatna>
        <spatna cesta="">volatile</spatna>
        <spatna cesta="">extends</spatna>
    </question>
    <question id="5">
        <otazka cesta="">Oznaète pravdivá tvrzení o konstruktoru</otazka>
        <spravna cesta="">mùže volat konstruktor tøídy-pøedka</spravna>
        <spatna cesta="">každá tøída má vždy implicitní veøejný bezparametrický konstruktor</spatna>
        <spravna cesta="">mùže být privátní</spravna>
        <spatna cesta="">nemùže mít nikdy parametry</spatna>
        <spatna cesta="">má návratový typ void</spatna>
    </question>
    <question id="6">
        <otazka cesta="">Tzv. gettery a settery se používají k</otazka>
        <spatna cesta="">ke vložení/získání instance ze zásobníku virtuálního stroje</spatna>
        <spatna cesta="">ke komunikaci se zdrojovým kódem mimo jazyk Java</spatna>
        <spatna cesta="">takové konstrukce se v Javì nepoužívají</spatna>
        <spravna cesta="">zapouzdøení nastavení a získání hodnoty ze soukromé promìnné tøídy</spravna>
        <spatna cesta="">k vytvoøení a zrušení instance dané tøídy</spatna>
    </question>
    <question id="7">
        <otazka cesta="">Pro odstranìní objektu z pamìti používáme</otazka>
        <spatna cesta="">volání destruktoru</spatna>
        <spatna cesta="">volání funkce "clear"</spatna>
        <spatna cesta="">volání funkce "unalloc"</spatna>
        <spatna cesta="">objekty se neruší a v pamìti zùstávájí až do ukonèení bìhu virtuálního stroje</spatna>
        <spravna cesta="">odstranìní odkazù na daný objekt; ten je poté pøedán ke zrušení garbage collectoru</spravna>
    </question>
    <question id="8">
        <otazka cesta="">Oznaète pravdivá tvrzení pro abstraktní tøídu X</otazka>
        <spatna cesta="">Tato konstrukce v jazyce Java neexistuje</spatna>
        <spatna cesta="">Mùže mít libovolný poèet pøímých pøedkù - jiných abstraktních tøíd.</spatna>
        <spravna cesta="">Lze vytvoøit tøídu, která bude potomkem/implementací X</spravna>
        <spravna cesta="">Lze volat metody u promìnné typu X</spravna>
        <spatna cesta="">Od X lze vytvoøit instanci</spatna>
    </question>
    <question id="9">
        <otazka cesta="">Pøi volání konstruktoru se objevuje klíèové slovo</otazka>
        <spravna cesta="">new</spravna>
        <spatna cesta="">extends</spatna>
        <spatna cesta="">call</spatna>
        <spatna cesta="">create</spatna>
        <spatna cesta="">implements</spatna>
    </question>
    <question id="10">
        <otazka cesta="">Klíèové slovo "static" se používá k</otazka>
        <spatna cesta="">takové slovo v jazyce Java neexistuje</spatna>
        <spatna cesta="">k definování vlastnosti s nemìnnou hodnotou</spatna>
        <spatna cesta="">k oznaèení metody, která vrací vždy stejný výsledek bez ohledu na stav objektu a pøedané parametry</spatna>
        <spravna cesta="">definování metod a promìnných, které patøí pøímo tøídì a jsou spoleèné pro všechny instance této tøídy</spravna>
        <spatna cesta="">k oznaèení metody, která nemìní obsah jí pøedaných parametrù</spatna>
    </question>
    <question id="11">
        <otazka cesta="">Oznaète pravdivá tvrzení pro statickou tøídu X</otazka>
        <spatna cesta="">Lze volat metody u promìnné typu X</spatna>
        <spatna cesta="">Od X lze vytvoøit instanci</spatna>
        <spravna cesta="">Tato konstrukce v jazyce Java neexistuje</spravna>
        <spatna cesta="">Mùže mít libovolný poèet pøedkù - jiných statických tøíd.</spatna>
        <spatna cesta="">Lze vytvoøit tøídu, která bude potomkem/implementací X</spatna>
    </question>
    <question id="12">
        <otazka cesta="">Jak se pøedávají objekty (ne primitivní typy) jako parametry pøi volání metod?</otazka>
        <spatna cesta="">tuto konstrukci Java nepodporuje</spatna>
        <spravna cesta="">pouze referencí</spravna>
        <spatna cesta="">lze hodnotou i referencí</spatna>
        <spatna cesta="">pouze hodnotou</spatna>
        <spatna cesta="">klonováním</spatna>
    </question>
    <question id="13">
        <otazka cesta="">Tøída se definuje pomocí klíèového slova</otazka>
        <spravna cesta="">class</spravna>
        <spatna cesta="">extends</spatna>
        <spatna cesta="">public</spatna>
        <spatna cesta="">volatile</spatna>
        <spatna cesta="">interface</spatna>
    </question>
    <question id="14">
        <otazka cesta="">Identifikátor používající se pøi testování v JUnit pro ohodnocení shodnosti/korektnosti výsledku je:</otazka>
        <spravna cesta="">assert</spravna>
        <spatna cesta="">view</spatna>
        <spatna cesta="">equal</spatna>
        <spatna cesta="">test</spatna>
        <spatna cesta="">analyze</spatna>
    </question>
    <question id="15">
        <otazka cesta="">Správný postup pøi vývoji pomocí TDD je:</otazka>
        <spatna cesta="">Vytvoøit celou aplikace. Po jejím vytvoøení vytvoøit všechny testy. Po ovìøení všechno refaktorovat.</spatna>
        <spatna cesta="">Vytvoøit test, korektnì naimplementovat požadovanou funkcionalitu, ovìøit funkcionalitu testem.</spatna>
        <spatna cesta="">Pomocí refaktoringu vytvoøit funkcionalitu, potom navrhnout test a ovìøit funkcionalitu.</spatna>
        <spravna cesta="">Vytvoøit test, zbìžnì naimplementovat požadovanou funkcionalitu, po ovìøení testem ji pomocí refaktoringu upravit do výsledné formy.</spravna>
        <spatna cesta="">Vytvoøit funkcionalitu, zbìžnì navrhnout test, po ovìøení refaktorováním upravit test do výsledné formy.</spatna>
    </question>
    <question id="16">
        <otazka cesta="">Co je cílem refaktorování?</otazka>
        <spatna cesta="">Operace nutné k pøenesení aplikace na jinou platformu</spatna>
        <spravna cesta="">Odstranìní duplicit</spravna>
        <spravna cesta="">Vytvoøit co nejèistìjší a nejpøehlednìjší funkèní kód</spravna>
        <spatna cesta=""> Opravit chyby v nefunkèním kódu</spatna>
        <spatna cesta="">Pøeložit zdrojový kód pomocí efektivnìjšího kompilátoru do strojového kódu</spatna>
    </question>
    <question id="17">
        <otazka cesta="">Co je to unitový test?</otazka>
        <spatna cesta="">Test ovìøující funcionalitu modulù aplikace.</spatna>
        <spatna cesta="">Test ovìøující funkcionalitu výsledné aplikace jako celku</spatna>
        <spatna cesta="">Test ovìøující propojení nìkolika blokù systémù</spatna>
        <spatna cesta="">Jakýkoliv obecný test ovìøující funkcionalitu aplikace.</spatna>
        <spravna cesta="">Test ovìøující funkcionalitu funkènì jednoduchého bloku</spravna>
    </question>
    <question id="18">
        <otazka cesta="">Co je to funkèní test?</otazka>
        <spatna cesta="">Test ovìøující fukcionalitu konkrétní metody tøídy</spatna>
        <spatna cesta="">Test ovìøující funkcionalitu výsledné aplikace jako celku</spatna>
        <spatna cesta="">Jakýkoliv obecný test ovìøující funkcionalitu aplikace.</spatna>
        <spatna cesta="">Test ovìøující funkcionalitu funkènì jednoduchého bloku</spatna>
        <spravna cesta="">Test ovìøující funcionalitu modulù aplikace.</spravna>
    </question>
    <question id="19">
        <otazka cesta="">Jedním z frameworkù, který se používá pro TDD v Javì, je:</otazka>
        <spravna cesta="">JUnit</spravna>
        <spatna cesta="">.NETUnit</spatna>
        <spatna cesta="">Potøebné knihovny jsou souèástí Java SDK a nemají speciální název.</spatna>
        <spatna cesta="">xTester</spatna>
        <spatna cesta="">JavaTestDrivenDevelopmentUnit</spatna>
    </question>
    <question id="20">
        <otazka cesta="">Co je to integraèní test?</otazka>
        <spatna cesta="">Test ovìøující funkcionalitu funkènì jednoduchého bloku</spatna>
        <spatna cesta="">Jakýkoliv obecný test ovìøující funkcionalitu aplikace.</spatna>
        <spatna cesta="">Test ovìøující funcionalitu modulù aplikace.</spatna>
        <spravna cesta="">Test ovìøující funkcionalitu výsledné aplikace jako celku</spravna>
        <spatna cesta="">Test ovìøující fukcionalitu konkrétní metody tøídy</spatna>
    </question>
    <question id="21">
        <otazka cesta="">Testovací metody v JUnit mají prefix:</otazka>
        <spatna cesta="">assert</spatna>
        <spatna cesta="">set</spatna>
        <spravna cesta="">test</spravna>
        <spatna cesta="">view</spatna>
        <spatna cesta="">check</spatna>
    </question>
    <question id="22">
        <otazka cesta="">K èemu slouží wrappery pro primitivní typy?</otazka>
        <spatna cesta="">Zapouzdrují objektové typy, aby je šlo použít spolu s primitivními typy.</spatna>
        <spatna cesta="">Zapouzdøují primitivní typ, aby zabránili vložení nekorektní hodnoty.</spatna>
        <spatna cesta="">Wrappery nelze použít s primitivními typy.</spatna>
        <spravna cesta="">Zapouzdøují primitivní typ do tøídy, aby jej šlo použít jako referenèní typ. </spravna>
        <spatna cesta="">Zapouzdøují primitivní typ, aby jej šlo zkompilovat v nové verzi javy 6.</spatna>
    </question>
    <question id="23">
        <otazka cesta="">Oznaète pravdivé výroky ohlednì metody toString():</otazka>
        <spravna cesta="">Metoda se používá pro získání hodnoty objektu transformovaného na øetìzec.</spravna>
        <spravna cesta="">Existuje primitivní typ, který nemá metodu toString()</spravna>
        <spatna cesta="">Metodu nelze pøetížit.</spatna>
        <spravna cesta="">Metoda je definována v datovém typu Object.</spravna>
        <spatna cesta="">Existuje referenèní typ, který nemá metodu toString()</spatna>
    </question>
    <question id="24">
        <otazka cesta="">Vyberte pravdivá tvrzení o primitivních typech:</otazka>
        <spravna cesta="">Pøedávají se hodnotou</spravna>
        <spravna cesta="">Pomocí wrapovacích typù je lze používat jako typy referenèní</spravna>
        <spatna cesta="">Dìdí z obecného typu Object</spatna>
        <spravna cesta="">Nepatøí do objektové hierarchie typù</spravna>
        <spatna cesta="">Pøedávají se referencí</spatna>
        <spatna cesta="">V Javì existují bezznaménkové prmitivní typy (s rozsahem pouze kladných èísel)</spatna>
        <spatna cesta="">V Javì existují znaménkové primitivní typy (s rozsahem záporných i kladných èísel) </spatna>
    </question>
    <question id="25">
        <otazka cesta="">Jaký je význam existence tøídy StringBuilder?</otazka>
        <spravna cesta="">Umožòuje vytvoøit dlouhý øetìzec pomocí skládání jednotlivých èástí metodou append.</spravna>
        <spatna cesta="">Umožòuje naèítat øetìzec automatizovanì ze souboru.</spatna>
        <spatna cesta="">Taková tøída v Javì neexistuje.</spatna>
        <spravna cesta="">Umožòuje mìnit promìnnou s øetìzcem, aniž by se pro každou zmìnu musela vytváøet nová instance.</spravna>
        <spatna cesta="">Umožòuje bezpeènì vícevláknovì pøistupovat pøi ètení z promìnné øetìzce.</spatna>
    </question>
    <question id="26">
        <otazka cesta="">Které z následujících dvojic hodnot èísel a datových typù si odpovídají?</otazka>
        <spravna cesta="">170L - long</spravna>
        <spatna cesta="">34.453 - float</spatna>
        <spatna cesta="">170i - int</spatna>
        <spravna cesta="">84.455f - float</spravna>
        <spravna cesta="">170 - int</spravna>
    </question>
    <question id="27">
        <otazka cesta="">Správné operace s øetìzce realizují výrazy:</otazka>
        <spatna cesta="">String repl = s.replace(2,3,4,5);</spatna>
        <spatna cesta="">String s = "Dobrý + den."";</spatna>
        <spravna cesta="">String s = "Dobrý " + "den.";</spravna>
        <spravna cesta="">boolean shodné = s.equals("Dobrý den");</spravna>
        <spatna cesta="">String part = s.delete(4,6);</spatna>
    </question>
    <question id="28">
        <otazka cesta="">Nejvyšším datovým typem v hierarchii objektù v Javì je:</otazka>
        <spatna cesta="">Type</spatna>
        <spatna cesta="">Top</spatna>
        <spatna cesta="">Class</spatna>
        <spravna cesta="">Object</spravna>
        <spatna cesta="">Parent</spatna>
    </question>
    <question id="29">
        <otazka cesta="">Chci-li vytisknout nebo parsovat hodnotu data ve formátu 14. ledna 2001 08:20, použiji:</otazka>
        <spravna cesta="">instanci tøídy SimpleDateFormat s nastavením formátovacího øetìzce na dd. MMMM yyyy hh:mm</spravna>
        <spravna cesta="">instanci tøídy TimeZone s nastavením formátovacího øetìzce na dd. MMMM yyyy hh:mm</spravna>
        <spatna cesta="">instanci tøídy Locale s nastavením formátovacího øetìzce na dd. MMMM yyyy HH:mm</spatna>
        <spatna cesta="">instanci tøídy Date s nastavením formátovacího øetìzce na dd. MMMM yyyy hh:mm </spatna>
        <spatna cesta="">instanci tøídy SimpleDateFormat s nastavením formátovacího øetìzce na d. M y h:m</spatna>
    </question>
    <question id="30">
        <otazka cesta="">S jakou pøesností reprezentují datum a èas bìžné tøídy v jazyce Java?</otazka>
        <spatna cesta="">Na sekundy</spatna>
        <spatna cesta="">Na dny</spatna>
        <spravna cesta="">Na milisekundy</spravna>
        <spatna cesta="">Na minuty</spatna>
    </question>
    <question id="31">
        <otazka cesta="">Které z následujících hodnot mùžete získat jako informace z instance tøídy java.util.Date?</otazka>
        <spatna cesta="">Hodiny</spatna>
        <spatna cesta="">Roky</spatna>
        <spatna cesta="">Sekundy</spatna>
        <spatna cesta="">Dny</spatna>
        <spravna cesta="">Milisekundy</spravna>
    </question>
    <question id="32">
        <otazka cesta="">Tøída java.util.GregorianCalendar reprezentuje datum pomocí:</otazka>
        <spravna cesta="">tøídní promìnné typu "long" udržující poèet milisekund od urèitého data</spravna>
        <spravna cesta="">tøídních promìnných udržujících postupnì hodnoty pro rok-mìsíc-den-hodina-minuta-sekunda</spravna>
        <spatna cesta="">hash kódu a metody getHashCode()</spatna>
        <spatna cesta="">nijak, tøída reprentuje pouze chování kalendáøe (napø. poèet dní v mìsíci), nikoliv aktuální datum</spatna>
        <spatna cesta="">pomocí vnitøní promìnné java.util.Date</spatna>
    </question>
    <question id="33">
        <otazka cesta="">Pøevod mezi java.util.Date a java.util.Calendar se provádí pomocí:</otazka>
        <spravna cesta="">pomocí mezikroku a pøevodu pøes milisekundy a metod toTime() a get/setTimeInMilis()</spravna>
        <spatna cesta="">pomocí mezikroku a pøevodu pøes hodiny (v desetinném formátu) a metod toTime() a get/setTimeInMilis()</spatna>
        <spatna cesta="">metod fromCalendar/toCalendar tøídy java.util.Date</spatna>
        <spatna cesta="">java.util.Calendar vnitønì obsahuje java.util.Date, takže pøevod se nemusí provádìt</spatna>
        <spatna cesta="">explicitního volání kontruktoru obou tøíd se zadáním hodnot rok-mìsíc-den-hodina-minuta-sekunda-milisekunda</spatna>
    </question>
    <question id="34">
        <otazka cesta="">Mùžete si v Javì naprogramovat vlastní, fiktivní kalendáø, využívající pouze 10 mìsícù v roce?</otazka>
        <spatna cesta="">Ne</spatna>
        <spravna cesta="">Ano, jako potomka tøídy java.util.Calendar</spravna>
        <spatna cesta="">Ano, ale pouze jako samostatnou tøídu</spatna>
        <spatna cesta="">Ano, jako potomka tøídy java.util.Date</spatna>
    </question>
    <question id="35">
        <otazka cesta="">Lze pøevést instanci tøídy java.util.Date na instanci tøídy java.util.GregorianCalendar?</otazka>
        <spravna cesta="">Ano, pomocí metody</spravna>
        <spatna cesta="">Ano, pøímo pomocí pøetypování</spatna>
        <spatna cesta="">Složitì pøes instanci tøídy String</spatna>
        <spatna cesta="">Ne</spatna>
    </question>
    <question id="36">
        <otazka cesta="">Lze pøevést instanci tøídy java.util.GregorianCalendar na instanci tøídy java.util.Date?</otazka>
        <spatna cesta="">Ne</spatna>
        <spatna cesta="">Ano, pøímo pomocí pøetypování</spatna>
        <spravna cesta="">Ano, pomocí metod</spravna>
        <spatna cesta="">Složitì pøes instanci tøídy String</spatna>
    </question>
    <question id="37">
        <otazka cesta="">Tøída urèená k formátování øetìzce na datum a zpìt se jmenuje:</otazka>
        <spatna cesta="">java.util.Locale</spatna>
        <spatna cesta="">java.util.TimeZone</spatna>
        <spatna cesta="">java.util.Date</spatna>
        <spravna cesta="">java.text.SimpleDateFormat </spravna>
        <spatna cesta="">java.util.Calendar</spatna>
    </question>
    <question id="38">
        <otazka cesta="">Lze vytvoøit instanci tøídy java.util.Calendar?</otazka>
        <spatna cesta="">Ano</spatna>
        <spravna cesta="">Ne</spravna>
        <spatna cesta="">Jen z instance tøídy String</spatna>
        <spatna cesta="">Jen z instance tøídy java.util.Date</spatna>
    </question>
    <question id="39">
        <otazka cesta="">Hodnotu aktuálního data získáme z tøídy java.util.Calendar pomocí:</otazka>
        <spatna cesta="">volání statické metody getCurrent();</spatna>
        <spatna cesta="">volání bezparametrického konstruktoru</spatna>
        <spatna cesta="">pouze a jen explicitnì voláním konstruktoru tøídy s parametry rok-mìsíc-den-hodina-minuta-sekunda-milisekunda</spatna>
        <spatna cesta="">volání nestatické (instanèní) metody getNow();</spatna>
        <spravna cesta="">volání statické metody getInstance()</spravna>
    </question>
    <question id="40">
        <otazka cesta="">Základní metody pro úpravu aktuálního data v kalendáøi jsou:</otazka>
        <spatna cesta="">remove()</spatna>
        <spatna cesta="">append()</spatna>
        <spravna cesta="">roll() </spravna>
        <spravna cesta="">add()</spravna>
        <spravna cesta="">set()</spravna>
    </question>
    <question id="41">
        <otazka cesta="">Lidsky èitelnou hodnotu v instanci tøídy java.util.Date získáme nejrychleji pomocí:</otazka>
        <spatna cesta="">volání metod getTime().toString()</spatna>
        <spatna cesta="">nelze získat, musí se použít pøevod na typ java.util.Calendar</spatna>
        <spatna cesta="">volání metody toDateString</spatna>
        <spravna cesta="">volání metody toString()</spravna>
        <spatna cesta="">volání metody printDate()</spatna>
    </question>
    <question id="42">
        <otazka cesta="">Korektní syntaxe pro vytvoøení promìnné pro reprezentaci matice 3x3 bude:</otazka>
        <spatna cesta="">int [[]] mat = new int [3[3]];</spatna>
        <spatna cesta="">int [,] mat = new int [3, 3];</spatna>
        <spravna cesta="">int [][] mat = new int [3][3];</spravna>
        <spatna cesta="">takové pole nelze v Javì vytvoøit</spatna>
        <spatna cesta="">int [..] mat = new int [3..3];</spatna>
    </question>
    <question id="43">
        <otazka cesta="">Chci udržovat sadu prvkù, do které chci prvky pøidávat a chci pozdìji mìnit jejich hodnoty. Použiji nejlépe:</otazka>
        <spatna cesta="">Mapu</spatna>
        <spatna cesta="">Množinu</spatna>
        <spatna cesta="">Pole</spatna>
        <spravna cesta="">List</spravna>
    </question>
    <question id="44">
        <otazka cesta="">Co je to pole?</otazka>
        <spatna cesta="">Základní datová struktura urèená k udržení a reprezentaci souètu daných prvkù</spatna>
        <spravna cesta="">Základní datová struktura urèená k udržení a reprezentaci pøedem daného, statického poètu prvkù stejného typu</spravna>
        <spatna cesta="">Takový pojem v programování v Javì neexistuje, byl nahrazen pojmem Kolekce.</spatna>
        <spatna cesta="">Základní datová struktura urèená k udržení a reprezentaci libovolnì mìnitelného poètu prvkù stejného typu</spatna>
    </question>
    <question id="45">
        <otazka cesta="">Pro prùchod pøes desetiprvkové pole v Javì použijeme cyklus:</otazka>
        <spatna cesta="">for (int i = 1; i &lt; 10; i++)</spatna>
        <spatna cesta="">for (int i = 1; i &lt;= 10; i++)</spatna>
        <spravna cesta="">for (int i = 0; i &lt; 10; i++) </spravna>
        <spatna cesta="">for (int i = 0; i &lt; 9; i++)</spatna>
        <spatna cesta="">for (int i = 0; i &lt;= 10; i++)</spatna>
    </question>
    <question id="46">
        <otazka cesta="">Korektní syntaxe pro definici 5-prvkového pole s indexy od 2 do 6 je:</otazka>
        <spravna cesta="">takové pole nelze v Javì vytvoøit</spravna>
        <spatna cesta="">int [] i = new int[2,5];</spatna>
        <spatna cesta="">int [] i = new int[2-6];</spatna>
        <spatna cesta="">int [] i = new int[2..6];</spatna>
        <spatna cesta="">int [] i = new int[2,6];</spatna>
    </question>
    <question id="47">
        <otazka cesta="">Korektní syntaxe pro vytvoøení pole v Javì je:</otazka>
        <spravna cesta="">int [] i = new int {2, 3, 4};</spravna>
        <spatna cesta="">int () i = new int (5);</spatna>
        <spravna cesta="">int [] i = new int [5];</spravna>
        <spatna cesta="">int {} i = new int {5}</spatna>
        <spatna cesta="">int i [] = new int [5];</spatna>
    </question>
    <question id="48">
        <otazka cesta="">Korektní metody, které lze volat nad kolekcí typu "ArrayList" jsou: </otazka>
        <spravna cesta="">kol.add(4);</spravna>
        <spatna cesta="">Integer i = kol[4];</spatna>
        <spravna cesta="">kol.get(3);</spravna>
        <spravna cesta="">kol.set(5,3);</spravna>
        <spatna cesta="">kol[4] = 5; </spatna>
    </question>
    <question id="49">
        <otazka cesta="">Pro vyhledání hodnoty 4 v poli "x" použijeme výraz:</otazka>
        <spatna cesta="">int index = Arrays.binarySearch(x, 4); // pole nemusí být pøedem seøazeno</spatna>
        <spatna cesta="">int index = x.binarySearch(4); // pole musí být pøedem seøazeno</spatna>
        <spatna cesta="">int index = x.find(4); // pole musí být pøedem seøazeno</spatna>
        <spatna cesta="">int index = x.search(4); // pole musí být pøedem seøazeno</spatna>
        <spravna cesta="">int index = Arrays.binarySearch(x, 4); // pole musí být pøedem seøazeno</spravna>
    </question>
    <question id="50">
        <otazka cesta="">Pro seøazení pole "x" použijeme výraz:</otazka>
        <spatna cesta="">x.sort(Arrays);</spatna>
        <spravna cesta="">Arrays.sort(x);</spravna>
        <spatna cesta="">x.sort();</spatna>
        <spatna cesta="">x.Sort();</spatna>
        <spatna cesta="">sort(x);</spatna>
    </question>
    <question id="51">
        <otazka cesta="">Zatrhnìte dvojici deklarací, které po kompilaci zahlásí chybu upozoròující na opakovaný výskyt stejné metody se stejnou signaturou:</otazka>
        <spatna cesta="">public int add(List&lt;int&gt; data)</spatna>
        <spatna cesta="">public void add&lt;T&gt;(List&lt;T&gt; data) </spatna>
        <spravna cesta="">public void add(List&lt;String&gt; data)</spravna>
        <spravna cesta="">public void add(List&lt;Integer&gt; data)</spravna>
    </question>
    <question id="52">
        <otazka cesta="">Který z následujících øádkù uvozuje generickou tøídu X:</otazka>
        <spatna cesta="">public class Y generic X</spatna>
        <spatna cesta="">public class X?Y</spatna>
        <spatna cesta="">public class Y&lt;X&gt;</spatna>
        <spravna cesta="">public class X&lt;Y&gt;</spravna>
    </question>
    <question id="53">
        <otazka cesta="">U kterých následujících výrazových prvkù jazyka lze bìžnou deklaraci rozšíøit na generickou?</otazka>
        <spravna cesta="">Metoda</spravna>
        <spatna cesta="">Tøídní instanèní promìnná</spatna>
        <spravna cesta="">Tøída</spravna>
        <spatna cesta="">Konstanta</spatna>
    </question>
    <question id="54">
        <otazka cesta="">Které z následujících písmen oznaèuje generický typ v deklaraci "public class A&lt;B&gt; extends C"</otazka>
        <spatna cesta="">C</spatna>
        <spravna cesta="">A</spravna>
        <spatna cesta="">B</spatna>
    </question>
    <question id="55">
        <otazka cesta="">Co je charakteristické pro výjimku, vyvolávanou v pøípadì selhální zdroje (napø. souboru, sítì) zpùsobeného mimo vlastní bìh aplikace?</otazka>
        <spatna cesta="">Je potomkem tøídy RuntimeException</spatna>
        <spravna cesta="">Je potomkem tøídy Exception</spravna>
        <spatna cesta="">Je potomkem tøídy Error</spatna>
        <spatna cesta="">Nemusí se zachytávat blokem try-catch-finally</spatna>
    </question>
    <question id="56">
        <otazka cesta="">Pro vyvolání výjimky se používá klíèové slovo:</otazka>
        <spravna cesta="">throw</spravna>
        <spatna cesta="">throws</spatna>
        <spatna cesta="">catch</spatna>
        <spatna cesta="">finally</spatna>
        <spatna cesta="">try</spatna>
    </question>
    <question id="57">
        <otazka cesta="">Co znamená, že výjimky jsou "øetìzené":</otazka>
        <spatna cesta="">že klienský kód musí výjimku buï ošetøit, nebo ji propagovat</spatna>
        <spatna cesta="">že kompilátor kontroluje syntaxi zapsaných try-catch-finally blokù</spatna>
        <spatna cesta="">takový termín neexistuje.</spatna>
        <spatna cesta="">že JVM kontroluje chyby a vyvolává pøípadné výjimky</spatna>
        <spravna cesta="">že lze do nové instance výjimky vložit již existující instanci jiné výjimky</spravna>
    </question>
    <question id="58">
        <otazka cesta="">Kolikrát mùžeme použít podblok "finally" v sekvenci try-catch-finally?</otazka>
        <spatna cesta="">0x - 3x</spatna>
        <spravna cesta="">0x - 1x</spravna>
        <spatna cesta="">1x</spatna>
        <spatna cesta="">Libovolnìkrát</spatna>
        <spatna cesta="">2x</spatna>
    </question>
    <question id="59">
        <otazka cesta="">Který z následujících výrazù je korektní vyvolání výjimky?</otazka>
        <spravna cesta="">throw new Exception ("Chyba.");</spravna>
        <spatna cesta="">throw Exception ("Chyba.");</spatna>
        <spatna cesta="">throws new Exception ("Chyba.");</spatna>
        <spatna cesta="">throws Exception ("Chyba.);</spatna>
        <spatna cesta="">throws Exception ("Chyba.");</spatna>
    </question>
    <question id="60">
        <otazka cesta="">Kolikrát mùžeme použít podblok "try" v sekvenci try-catch-finally?</otazka>
        <spatna cesta="">2x</spatna>
        <spatna cesta="">0x - 3x</spatna>
        <spatna cesta="">Libovolnìkrát</spatna>
        <spravna cesta="">1x</spravna>
        <spatna cesta="">0x - 1x</spatna>
    </question>
    <question id="61">
        <otazka cesta="">Pro uvození bloku, který zkusí provést zadané pøíkazy, se používá klíèové slovo:</otazka>
        <spatna cesta="">catch</spatna>
        <spatna cesta="">throw</spatna>
        <spatna cesta="">finally</spatna>
        <spatna cesta="">throws</spatna>
        <spravna cesta="">try</spravna>
    </question>
    <question id="62">
        <otazka cesta="">Pro uvození bloku, který bude zachytávat pøípadnou výjimku, se používá klíèové slovo:</otazka>
        <spravna cesta="">catch</spravna>
        <spatna cesta="">throw</spatna>
        <spatna cesta="">try</spatna>
        <spatna cesta="">throws</spatna>
        <spatna cesta="">finally</spatna>
    </question>
    <question id="63">
        <otazka cesta="">Který z následujících výrazù je korektní úvod bloku pro zachycení výjimky?</otazka>
        <spravna cesta="">catch (Exception ex)</spravna>
        <spatna cesta="">finally (Exception)</spatna>
        <spatna cesta="">catch</spatna>
        <spatna cesta="">catchs (Exception ex)</spatna>
        <spatna cesta="">catch (Exception)</spatna>
    </question>
    <question id="64">
        <otazka cesta="">Jakým zpùsobem øeší jazyk Java práci s odlišnými souborovými systémy rùzných operaèních systémù?</otazka>
        <spatna cesta="">Java umožòuje pracovat pouze se souborovým systémem FATxx a NTFS, které jsou vzájemnì kompatibilní.</spatna>
        <spatna cesta="">Každý souborový systém má svého potomka abstraktních tøíd, které realizují operace pro daný souborový systém</spatna>
        <spravna cesta="">Vše zapouzdøuje do jedné knihovny umožòující pracovat s libovolnými souborovými systémy</spravna>
        <spatna cesta="">Každý souborový systém má svùj vlastní balíèek, který obsahuje tøídy, které zpracovávají daný souborový systém</spatna>
    </question>
    <question id="65">
        <otazka cesta="">Tøídy pro práci se soubory a souborovým systémem lze nalézt v balíèku:</otazka>
        <spravna cesta="">java.io</spravna>
        <spravna cesta="">java.nio</spravna>
        <spatna cesta="">java.data</spatna>
        <spatna cesta="">java.files</spatna>
    </question>
    <question id="66">
        <otazka cesta="">Základní tøídou reprezentující urèitý objekt na disku, je tøída "java.io.File". Pokud vytvoøíme instanci pøedáním urèité cesty (napø. C:\windows\windows.ini), musí tento objekt existovat?</otazka>
        <spravna cesta="">Ne.</spravna>
        <spatna cesta="">Ano.</spatna>
        <spatna cesta="">Ne, ale pøi vytvoøení instance se automaticky vytvoøí.</spatna>
        <spatna cesta="">Ne, ale programátor jej musí v prùbìhu bìhu aplikace vytvoøit.</spatna>
    </question>
    <question id="67">
        <otazka cesta="">Základní tøídou reprezentující urèitý objekt na disku, je tøída "java.io.File". Instance této tøídy reprezentuje:</otazka>
        <spravna cesta="">Složku</spravna>
        <spatna cesta="">Jedná se o abstraktní tøídu.</spatna>
        <spatna cesta="">Seznam atributù souboru</spatna>
        <spravna cesta="">Soubor</spravna>
    </question>
    <question id="68">
        <otazka cesta="">Výjimky pøi práci se streamy:</otazka>
        <spatna cesta="">Není tøeba zachytávat, typicky operace vyhazují java.io.IOException, která je systémová (Error) a nelze ji explicitnì zachytit.</spatna>
        <spatna cesta="">Není tøeba zachytávat, typicky operace vyhazují java.io.IOException, která je bìhová a nemusí se explicitnì zachytit.</spatna>
        <spatna cesta="">Nevyhazují se explicitnì výjimky, není tøeba zachytávat.</spatna>
        <spravna cesta="">Je tøeba zachytávat, typicky operace vyhazují java.io.IOException.</spravna>
    </question>
    <question id="69">
        <otazka cesta="">V Javì se se soubory pracuje pomocí tzv. streamù. Tyto streamy lze (v javì typicky) dìlit do kategorií na:</otazka>
        <spravna cesta="">Vstupní a výstupní</spravna>
        <spatna cesta="">Zabezpeèené a nezabezpeèené</spatna>
        <spatna cesta="">Šifrované a nešifrované</spatna>
        <spravna cesta="">Bytové a textové</spravna>
    </question>
    <question id="70">
        <otazka cesta="">Výstupní bytový proud pro RAR kompresi datových souborù bude nejlépe charakterizován tøídou:</otazka>
        <spravna cesta="">RarOutputStream</spravna>
        <spatna cesta="">RarWriter</spatna>
        <spatna cesta="">RarInputStream</spatna>
        <spatna cesta="">RarReader</spatna>
    </question>
    <question id="71">
        <otazka cesta="">Co je charakteristické pro filtrový (filtrovací) stream?</otazka>
        <spatna cesta="">Má bezparametrický veøejný konstruktor.</spatna>
        <spatna cesta="">Nemusí se uzavírat (provede uzavøení automaticky).</spatna>
        <spravna cesta="">Zapouzdøuje jiný stream.</spravna>
        <spatna cesta="">Nutnì bufferuje data.</spatna>
    </question>
    <question id="72">
        <otazka cesta="">Vstupní textový proud pro RAR dekompresi textu bude nejlépe charakterizován tøídou:</otazka>
        <spatna cesta="">RarWriter</spatna>
        <spravna cesta="">RarReader</spravna>
        <spatna cesta="">RarOutputStream</spatna>
        <spatna cesta="">RarInputStream</spatna>
    </question>
    <question id="73">
        <otazka cesta="">Základní operace pøi práci se streamy lze provádìt v poøadí:</otazka>
        <spatna cesta="">Otevøení, naètení do lokální promìnné, zpracování z lokální promìnné</spatna>
        <spravna cesta="">Otevøení, naètení do lokální promìnné, uzavøení, zpracování z lokální promìnné</spravna>
        <spatna cesta="">Otevøení, uzavøení, naètení do lokální promìnné, zpracování z lokální promìnné,</spatna>
        <spravna cesta="">Otevøení, naètení do lokální promìnné, zpracování z lokální promìnné, uzavøení </spravna>
    </question>
    <question id="74">
        <otazka cesta="">Technika, která umožòuje automatizovanì ukládat instanci tøídy do proudu dat, se nazývá:</otazka>
        <spatna cesta="">Persistence</spatna>
        <spatna cesta="">Materializace</spatna>
        <spatna cesta="">Exceptionalizace</spatna>
        <spravna cesta="">Serializace</spravna>
    </question>
</questions>
